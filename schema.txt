create table public.budget_data (
  id serial not null,
  year_month date not null,
  budget_type character varying(20) not null,
  category character varying(100) not null,
  subcategory character varying(50) null,
  budget_amount numeric(15, 2) not null default 0,
  actual_amount numeric(15, 2) null default 0,
  variance_amount numeric GENERATED ALWAYS as ((actual_amount - budget_amount)) STORED (15, 2) null,
  variance_percent numeric GENERATED ALWAYS as (
    case
      when (budget_amount = (0)::numeric) then (0)::numeric
      else (
        ((actual_amount - budget_amount) / budget_amount) * (100)::numeric
      )
    end
  ) STORED (8, 4) null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint budget_data_pkey primary key (id),
  constraint budget_data_year_month_budget_type_category_subcategory_key unique (year_month, budget_type, category, subcategory)
) TABLESPACE pg_default;

create index IF not exists idx_budget_data_month_type on public.budget_data using btree (year_month, budget_type) TABLESPACE pg_default;

create trigger auto_expense_category_budget_trigger BEFORE INSERT
or
update on budget_data for EACH row when (new.budget_type::text = 'expense'::text)
execute FUNCTION auto_create_expense_category ();

create trigger auto_revenue_category_budget_trigger BEFORE INSERT
or
update on budget_data for EACH row when (new.budget_type::text = 'revenue'::text)
execute FUNCTION auto_create_revenue_category ();

create table public.budget_data (
  id serial not null,
  year_month date not null,
  budget_type character varying(20) not null,
  category character varying(100) not null,
  subcategory character varying(50) null,
  budget_amount numeric(15, 2) not null default 0,
  actual_amount numeric(15, 2) null default 0,
  variance_amount numeric GENERATED ALWAYS as ((actual_amount - budget_amount)) STORED (15, 2) null,
  variance_percent numeric GENERATED ALWAYS as (
    case
      when (budget_amount = (0)::numeric) then (0)::numeric
      else (
        ((actual_amount - budget_amount) / budget_amount) * (100)::numeric
      )
    end
  ) STORED (8, 4) null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint budget_data_pkey primary key (id),
  constraint budget_data_year_month_budget_type_category_subcategory_key unique (year_month, budget_type, category, subcategory)
) TABLESPACE pg_default;

create index IF not exists idx_budget_data_month_type on public.budget_data using btree (year_month, budget_type) TABLESPACE pg_default;

create trigger auto_expense_category_budget_trigger BEFORE INSERT
or
update on budget_data for EACH row when (new.budget_type::text = 'expense'::text)
execute FUNCTION auto_create_expense_category ();

create trigger auto_revenue_category_budget_trigger BEFORE INSERT
or
update on budget_data for EACH row when (new.budget_type::text = 'revenue'::text)
execute FUNCTION auto_create_revenue_category ();

create table public.cash_flow (
  id serial not null,
  year_month date not null,
  flow_type character varying(20) not null,
  category character varying(50) not null,
  subcategory character varying(50) null,
  description text null,
  amount numeric(15, 2) not null default 0,
  is_recurring boolean null default true,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint cash_flow_pkey primary key (id),
  constraint cash_flow_year_month_flow_type_category_subcategory_key unique (year_month, flow_type, category, subcategory)
) TABLESPACE pg_default;

create index IF not exists idx_cash_flow_month_type on public.cash_flow using btree (year_month, flow_type) TABLESPACE pg_default;

create trigger auto_expense_category_trigger BEFORE INSERT
or
update on cash_flow for EACH row when (new.flow_type::text = 'outflow'::text)
execute FUNCTION auto_create_expense_category ();

create trigger auto_revenue_category_trigger BEFORE INSERT
or
update on cash_flow for EACH row when (new.flow_type::text = 'inflow'::text)
execute FUNCTION auto_create_revenue_category ();

create table public.churn_rates (
  id serial not null,
  year_month date not null,
  business_segment_id integer null,
  service_type character varying(20) not null,
  churn_rate numeric(5, 4) not null default 0,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint churn_rates_pkey primary key (id),
  constraint churn_rates_year_month_business_segment_id_service_type_key unique (year_month, business_segment_id, service_type),
  constraint churn_rates_business_segment_id_fkey foreign KEY (business_segment_id) references business_segments (id)
) TABLESPACE pg_default;

create table public.contractors (
  id serial not null,
  contractor_id character varying(20) not null,
  vendor character varying(100) not null,
  role character varying(100) not null,
  department character varying(50) null default 'Product Development'::character varying,
  resources numeric(5, 2) null default 0,
  hourly_rate numeric(8, 2) null default 0,
  start_date date null,
  end_date date null,
  is_active boolean null default true,
  created_at timestamp without time zone null default now(),
  updated_at timestamp without time zone null default now(),
  constraint contractors_pkey primary key (id),
  constraint contractors_contractor_id_key unique (contractor_id)
) TABLESPACE pg_default;

create table public.cost_of_sales (
  id serial not null,
  year_month date not null,
  revenue_category_id integer null,
  business_segment_id integer null,
  amount numeric(15, 2) not null default 0,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint cost_of_sales_pkey primary key (id),
  constraint cost_of_sales_year_month_revenue_category_id_business_segme_key unique (
    year_month,
    revenue_category_id,
    business_segment_id
  ),
  constraint cost_of_sales_business_segment_id_fkey foreign KEY (business_segment_id) references business_segments (id),
  constraint cost_of_sales_revenue_category_id_fkey foreign KEY (revenue_category_id) references revenue_categories (id)
) TABLESPACE pg_default;

create table public.cost_of_sales (
  id serial not null,
  year_month date not null,
  revenue_category_id integer null,
  business_segment_id integer null,
  amount numeric(15, 2) not null default 0,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint cost_of_sales_pkey primary key (id),
  constraint cost_of_sales_year_month_revenue_category_id_business_segme_key unique (
    year_month,
    revenue_category_id,
    business_segment_id
  ),
  constraint cost_of_sales_business_segment_id_fkey foreign KEY (business_segment_id) references business_segments (id),
  constraint cost_of_sales_revenue_category_id_fkey foreign KEY (revenue_category_id) references revenue_categories (id)
) TABLESPACE pg_default;

create table public.employee_bonuses (
  id serial not null,
  employee_id character varying(20) null,
  year_month date not null,
  bonus_type character varying(50) not null default 'performance'::character varying,
  bonus_amount numeric(10, 2) not null default 0,
  bonus_reason text null,
  approved_by character varying(100) null,
  bonus_date date null default CURRENT_DATE,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint employee_bonuses_pkey primary key (id),
  constraint employee_bonuses_employee_id_fkey foreign KEY (employee_id) references employees (employee_id)
) TABLESPACE pg_default;

create index IF not exists idx_employee_bonuses_month on public.employee_bonuses using btree (year_month) TABLESPACE pg_default;

create table public.employees (
  id serial not null,
  employee_id character varying(20) not null,
  name character varying(100) not null,
  title character varying(100) null,
  department character varying(50) null,
  pay_type character varying(20) null,
  weekly_hours numeric(5, 2) null default 40,
  annual_salary numeric(12, 2) null default 0,
  hourly_rate numeric(8, 2) null default 0,
  hire_date date null,
  termination_date date null,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint employees_pkey primary key (id),
  constraint employees_employee_id_key unique (employee_id)
) TABLESPACE pg_default;

create index IF not exists idx_employees_active on public.employees using btree (is_active, department) TABLESPACE pg_default;

create trigger employee_active_status_trigger BEFORE INSERT
or
update OF termination_date on employees for EACH row
execute FUNCTION trigger_update_employee_active ();

create table public.expense_categories (
  id serial not null,
  category_name character varying(50) not null,
  category_type character varying(20) not null,
  description text null,
  created_at timestamp with time zone null default now(),
  constraint expense_categories_pkey primary key (id),
  constraint expense_categories_category_name_key unique (category_name)
) TABLESPACE pg_default;

create table public.financial_ratios (
  id serial not null,
  year_month date not null,
  ratio_name character varying(50) not null,
  ratio_category character varying(30) null,
  ratio_value numeric(15, 4) not null default 0,
  numerator numeric(15, 2) not null default 0,
  denominator numeric(15, 2) not null default 0,
  business_segment_id integer null,
  benchmark_value numeric(15, 4) null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint financial_ratios_pkey primary key (id),
  constraint financial_ratios_year_month_ratio_name_business_segment_id_key unique (year_month, ratio_name, business_segment_id),
  constraint financial_ratios_business_segment_id_fkey foreign KEY (business_segment_id) references business_segments (id)
) TABLESPACE pg_default;

create table public.forecasts (
  id serial not null,
  year_month date not null,
  forecast_type character varying(50) not null,
  category character varying(100) not null,
  forecasted_value numeric(15, 2) not null default 0,
  confidence_level character varying(20) not null default 'medium'::character varying,
  forecast_method character varying(50) null,
  business_segment_id integer null,
  created_by character varying(100) null,
  forecast_created_at timestamp with time zone not null default now(),
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint forecasts_pkey primary key (id),
  constraint forecasts_year_month_forecast_type_category_business_segmen_key unique (
    year_month,
    forecast_type,
    category,
    business_segment_id
  ),
  constraint forecasts_business_segment_id_fkey foreign KEY (business_segment_id) references business_segments (id)
) TABLESPACE pg_default;

create table public.gross_profit_data (
  id serial not null,
  year_month date not null,
  revenue_category_id integer null,
  business_segment_id integer null,
  revenue_amount numeric(15, 2) not null default 0,
  cogs_amount numeric(15, 2) not null default 0,
  gross_profit numeric GENERATED ALWAYS as ((revenue_amount - cogs_amount)) STORED (15, 2) null,
  gross_margin_percent numeric GENERATED ALWAYS as (
    case
      when (revenue_amount = (0)::numeric) then (0)::numeric
      else (
        ((revenue_amount - cogs_amount) / revenue_amount) * (100)::numeric
      )
    end
  ) STORED (8, 4) null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint gross_profit_data_pkey primary key (id),
  constraint gross_profit_data_year_month_revenue_category_id_business_s_key unique (
    year_month,
    revenue_category_id,
    business_segment_id
  ),
  constraint gross_profit_data_business_segment_id_fkey foreign KEY (business_segment_id) references business_segments (id),
  constraint gross_profit_data_revenue_category_id_fkey foreign KEY (revenue_category_id) references revenue_categories (id)
) TABLESPACE pg_default;

create table public.hosting_costs (
  id serial not null,
  year_month date not null,
  cost_category character varying(50) not null,
  provider character varying(50) null,
  fixed_cost numeric(15, 2) null default 0,
  variable_cost numeric(15, 2) null default 0,
  total_cost numeric GENERATED ALWAYS as ((fixed_cost + variable_cost)) STORED (15, 2) null,
  active_customers integer null default 0,
  usage_metrics jsonb null,
  is_capitalized boolean null default false,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint hosting_costs_pkey primary key (id),
  constraint hosting_costs_year_month_cost_category_provider_key unique (year_month, cost_category, provider)
) TABLESPACE pg_default;

create table public.hosting_costs (
  id serial not null,
  year_month date not null,
  cost_category character varying(50) not null,
  provider character varying(50) null,
  fixed_cost numeric(15, 2) null default 0,
  variable_cost numeric(15, 2) null default 0,
  total_cost numeric GENERATED ALWAYS as ((fixed_cost + variable_cost)) STORED (15, 2) null,
  active_customers integer null default 0,
  usage_metrics jsonb null,
  is_capitalized boolean null default false,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint hosting_costs_pkey primary key (id),
  constraint hosting_costs_year_month_cost_category_provider_key unique (year_month, cost_category, provider)
) TABLESPACE pg_default;

create table public.hosting_costs (
  id serial not null,
  year_month date not null,
  cost_category character varying(50) not null,
  provider character varying(50) null,
  fixed_cost numeric(15, 2) null default 0,
  variable_cost numeric(15, 2) null default 0,
  total_cost numeric GENERATED ALWAYS as ((fixed_cost + variable_cost)) STORED (15, 2) null,
  active_customers integer null default 0,
  usage_metrics jsonb null,
  is_capitalized boolean null default false,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint hosting_costs_pkey primary key (id),
  constraint hosting_costs_year_month_cost_category_provider_key unique (year_month, cost_category, provider)
) TABLESPACE pg_default;

create table public.model_settings (
  id serial not null,
  setting_category character varying(50) not null,
  setting_name character varying(100) not null,
  setting_value jsonb not null,
  description text null,
  is_active boolean not null default true,
  data_type character varying(20) null default 'string'::character varying,
  updated_by character varying(100) null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint model_settings_pkey primary key (id),
  constraint model_settings_setting_category_setting_name_key unique (setting_category, setting_name)
) TABLESPACE pg_default;

create table public.pay_periods (
  id serial not null,
  year_month date not null,
  pay_periods_count integer not null default 2,
  special_notes text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint pay_periods_pkey primary key (id),
  constraint pay_periods_year_month_key unique (year_month)
) TABLESPACE pg_default;

create table public.payroll_costs (
  id serial not null,
  year_month date not null,
  employee_id character varying(20) null,
  department character varying(50) null,
  base_pay numeric(15, 2) not null default 0,
  overtime_pay numeric(15, 2) null default 0,
  bonus_pay numeric(15, 2) null default 0,
  total_pay numeric GENERATED ALWAYS as (((base_pay + overtime_pay) + bonus_pay)) STORED (15, 2) null,
  payroll_taxes numeric(15, 2) null default 0,
  benefits_cost numeric(15, 2) null default 0,
  total_cost numeric GENERATED ALWAYS as (
    (
      (
        ((base_pay + overtime_pay) + bonus_pay) + payroll_taxes
      ) + benefits_cost
    )
  ) STORED (15, 2) null,
  hours_worked numeric(8, 2) null,
  pay_periods_in_month integer null default 2,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint payroll_costs_pkey primary key (id),
  constraint payroll_costs_year_month_employee_id_key unique (year_month, employee_id),
  constraint payroll_costs_employee_id_fkey foreign KEY (employee_id) references employees (employee_id)
) TABLESPACE pg_default;

create index IF not exists idx_payroll_costs_month_dept on public.payroll_costs using btree (year_month, department) TABLESPACE pg_default;

create table public.payroll_costs (
  id serial not null,
  year_month date not null,
  employee_id character varying(20) null,
  department character varying(50) null,
  base_pay numeric(15, 2) not null default 0,
  overtime_pay numeric(15, 2) null default 0,
  bonus_pay numeric(15, 2) null default 0,
  total_pay numeric GENERATED ALWAYS as (((base_pay + overtime_pay) + bonus_pay)) STORED (15, 2) null,
  payroll_taxes numeric(15, 2) null default 0,
  benefits_cost numeric(15, 2) null default 0,
  total_cost numeric GENERATED ALWAYS as (
    (
      (
        ((base_pay + overtime_pay) + bonus_pay) + payroll_taxes
      ) + benefits_cost
    )
  ) STORED (15, 2) null,
  hours_worked numeric(8, 2) null,
  pay_periods_in_month integer null default 2,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint payroll_costs_pkey primary key (id),
  constraint payroll_costs_year_month_employee_id_key unique (year_month, employee_id),
  constraint payroll_costs_employee_id_fkey foreign KEY (employee_id) references employees (employee_id)
) TABLESPACE pg_default;

create index IF not exists idx_payroll_costs_month_dept on public.payroll_costs using btree (year_month, department) TABLESPACE pg_default;

create table public.revenue_categories (
  id serial not null,
  category_name character varying(50) not null,
  description text null,
  created_at timestamp with time zone null default now(),
  constraint revenue_categories_pkey primary key (id),
  constraint revenue_categories_category_name_key unique (category_name)
) TABLESPACE pg_default;

create table public.revenue_data (
  id serial not null,
  year_month date not null,
  revenue_category_id integer null,
  business_segment_id integer null,
  amount numeric(15, 2) not null default 0,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint revenue_data_pkey primary key (id),
  constraint revenue_data_year_month_revenue_category_id_business_segmen_key unique (
    year_month,
    revenue_category_id,
    business_segment_id
  ),
  constraint revenue_data_business_segment_id_fkey foreign KEY (business_segment_id) references business_segments (id),
  constraint revenue_data_revenue_category_id_fkey foreign KEY (revenue_category_id) references revenue_categories (id)
) TABLESPACE pg_default;

create index IF not exists idx_revenue_data_category_month on public.revenue_data using btree (revenue_category_id, year_month) TABLESPACE pg_default;

create index IF not exists idx_revenue_data_segment_month on public.revenue_data using btree (business_segment_id, year_month) TABLESPACE pg_default;

create table public.sga_expenses (
  id serial not null,
  year_month date not null,
  expense_category_id integer null,
  amount numeric(15, 2) not null default 0,
  notes text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint sga_expenses_pkey primary key (id),
  constraint sga_expenses_year_month_expense_category_id_key unique (year_month, expense_category_id),
  constraint sga_expenses_expense_category_id_fkey foreign KEY (expense_category_id) references expense_categories (id)
) TABLESPACE pg_default;
